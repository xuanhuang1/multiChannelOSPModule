




void startNewOSPRayFrame()
{
  if (updateFrameOpsNextFrame) {
    //framebuffer.commit();
    updateFrameOpsNextFrame = false;
  }
  currentFrame = framebuffer.renderFrame(*renderer_ptr, camera, world);
}

void waitOnOSPRayFrame()
{
  currentFrame.wait();
}

void addObjectToCommit(OSPObject obj)
{
  objectsToCommit.push_back(obj);
}

void commitOutstandingHandles()
{
  auto handles = objectsToCommit.consume();
  if (!handles.empty()) {
    for (auto &h : handles)
      ospCommit(h);
    framebuffer.resetAccumulation();
  }
}

void error_callback(int error, const char *desc)
{
  std::cerr << "error " << error << ": " << desc << std::endl;
}


void GLFWCreateWindow()
{
  //if (activeWindow != nullptr) {
  //  throw std::runtime_error("Cannot create more than one GLFWOSPRayWindow!");
  // }

  //activeWindow = this;

  glfwSetErrorCallback(error_callback);

  // initialize GLFW
  if (!glfwInit()) {
    throw std::runtime_error("Failed to initialize GLFW!");
  }

  glfwWindowHint(GLFW_SRGB_CAPABLE, GLFW_TRUE);
  // create GLFW window
  glfwWindow = glfwCreateWindow(
      windowSize.x, windowSize.y, "OSPRay Tutorial", nullptr, nullptr);

  if (!glfwWindow) {
    glfwTerminate();
    throw std::runtime_error("Failed to create GLFW window!");
  }

  // make the window's context current
  glfwMakeContextCurrent(glfwWindow);

  ImGui_ImplGlfwGL3_Init(glfwWindow, true);

  // set initial OpenGL state
  glEnable(GL_TEXTURE_2D);
  glDisable(GL_LIGHTING);

  // create OpenGL frame buffer texture
  glGenTextures(1, &framebufferTexture);
  glBindTexture(GL_TEXTURE_2D, framebufferTexture);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

  // set GLFW callbacks
  //glfwSetFramebufferSizeCallback(
  //     glfwWindow, [](GLFWwindow *, int newWidth, int newHeight) {
  //      activeWindow->reshape(vec2i{newWidth, newHeight});
  //    });

  //glfwSetCursorPosCallback(glfwWindow, [](GLFWwindow *, double x, double y) {
  //  ImGuiIO &io = ImGui::GetIO();
  //  if (!activeWindow->showUi || !io.WantCaptureMouse) {
  //    activeWindow->motion(vec2f{float(x), float(y)});
  //  }
  //});
  /*
  glfwSetKeyCallback(
      glfwWindow, [](GLFWwindow *, int key, int, int action, int) {
        if (action == GLFW_PRESS) {
          switch (key) {
          case GLFW_KEY_G:
            activeWindow->showUi = !(activeWindow->showUi);
            break;
          case GLFW_KEY_Q:
            g_quitNextFrame = true;
            break;
          }
        }
	});*/

  //  glfwSetMouseButtonCallback(
			     //  glfwWindow, [](GLFWwindow *, int button, int action, int /*mods*/) {
		    /*        auto &w = *activeWindow;
        if (button == GLFW_MOUSE_BUTTON_MIDDLE && action == GLFW_PRESS) {
          auto mouse = activeWindow->previousMouse;
          auto windowSize = activeWindow->windowSize;
          const vec2f pos(mouse.x / static_cast<float>(windowSize.x),
              1.f - mouse.y / static_cast<float>(windowSize.y));

          auto res =
              w.framebuffer.pick(*w.renderer, w.camera, w.world, pos.x, pos.y);

          if (res.hasHit) {
            std::cout << "Picked geometry [inst: " << res.instance
                      << ", model: " << res.model << ", prim: " << res.primID
                      << "]" << std::endl;
          }
        }
      });
*/
  // OSPRay setup //

  // set up backplate texture
  std::vector<vec4f> backplate;
  backplate.push_back(vec4f(0.8f, 0.2f, 0.2f, 1.0f));
  backplate.push_back(vec4f(0.2f, 0.8f, 0.2f, 1.0f));
  backplate.push_back(vec4f(0.2f, 0.2f, 0.8f, 1.0f));
  backplate.push_back(vec4f(0.4f, 0.2f, 0.4f, 1.0f));

  OSPTextureFormat texFmt = OSP_TEXTURE_RGBA32F;
  backplateTex.setParam("data",
			ospray::cpp::CopiedData(backplate.data(),
						vec2ul(2, 2)));
  backplateTex.setParam("format", OSP_INT, &texFmt);
  addObjectToCommit(backplateTex.handle());

  //refreshScene(true);

  // trigger window reshape events with current window size
  glfwGetFramebufferSize(glfwWindow, &windowSize.x, &windowSize.y);
  //reshape(this->windowSize);

  commitOutstandingHandles();
}

void display()
{
  glEnable(GL_FRAMEBUFFER_SRGB); // Turn on sRGB conversion for OSPRay frame

  static bool firstFrame = true;
  if (firstFrame || currentFrame.isReady()) {
    currentFrame.wait();
  
    latestFPS = 1.f / currentFrame.duration();

    auto *fb = framebuffer.map(
        showDepth ? OSP_FB_DEPTH : (showAlbedo ? OSP_FB_ALBEDO : OSP_FB_COLOR));

    glBindTexture(GL_TEXTURE_2D, framebufferTexture);
    glTexImage2D(GL_TEXTURE_2D,
        0,
        showAlbedo ? GL_RGB32F : GL_RGBA32F,
        windowSize.x,
        windowSize.y,
        0,
        showDepth ? GL_RED : (showAlbedo ? GL_RGB : GL_RGBA),
        GL_FLOAT,
        fb);

    framebuffer.unmap(fb);

    commitOutstandingHandles();

    startNewOSPRayFrame();
    firstFrame = false;
  }

  // clear current OpenGL color buffer
  glClear(GL_COLOR_BUFFER_BIT);

  // render textured quad with OSPRay frame buffer contents
  glBegin(GL_QUADS);

  glTexCoord2f(0.f, 0.f);
  glVertex2f(0.f, 0.f);

  glTexCoord2f(0.f, 1.f);
  glVertex2f(0.f, windowSize.y);

  glTexCoord2f(1.f, 1.f);
  glVertex2f(windowSize.x, windowSize.y);

  glTexCoord2f(1.f, 0.f);
  glVertex2f(windowSize.x, 0.f);

  glEnd();

  /*if (showUi) {
    glDisable(GL_FRAMEBUFFER_SRGB); // Disable SRGB conversion for UI

    ImGui::Render();
    ImGui_ImplGlfwGL3_Render();
    }*/

  // swap buffers
  glfwSwapBuffers(glfwWindow);
}



// Copyright 2009-2021 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

/* This is a small example tutorial how to use OSPRay in an application.
 *
 * On Linux build it in the build_directory with
 *   g++ ../apps/ospTutorial/ospTutorial.cpp -I ../ospray/include \
 *       -I ../../rkcommon -L . -lospray -Wl,-rpath,. -o ospTutorial
 * On Windows build it in the build_directory\$Configuration with
 *   cl ..\..\apps\ospTutorial\ospTutorial.cpp /EHsc -I ..\..\ospray\include ^
 *      -I ..\.. -I ..\..\..\rkcommon ospray.lib
 * Above commands assume that rkcommon is present in a directory right "next
 * to" the OSPRay directory. If this is not the case, then adjust the include
 * path (alter "-I <path/to/rkcommon>" appropriately).
 */

#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#ifdef _WIN32
#define NOMINMAX
#include <conio.h>
#include <malloc.h>
#include <windows.h>
#else
#include <alloca.h>
#endif

//#include <vector>

#include "ospray/ospray_cpp.h"
#include "ospray/ospray_cpp/ext/rkcommon.h"
#include "rkcommon/utility/SaveImage.h"
#include "rkcommon/utility/random.h"
#include "rkcommon/tasking/parallel_for.h"
// stl
#include <random>
#include <vector>

using namespace rkcommon;
using namespace rkcommon::math;


ospray::cpp::TransferFunction makeTransferFunction(const vec2f &valueRange)
{
  ospray::cpp::TransferFunction transferFunction("piecewiseLinear");
  std::string tfColorMap{"rgb"};
  std::string tfOpacityMap{"linear"};
  
  std::vector<vec3f> colors;
  std::vector<float> opacities;

  if (tfColorMap == "jet") {
    colors.emplace_back(0, 0, 0.562493);
    colors.emplace_back(0, 0, 1);
    colors.emplace_back(0, 1, 1);
    colors.emplace_back(0.500008, 1, 0.500008);
    colors.emplace_back(1, 1, 0);
    colors.emplace_back(1, 0, 0);
    colors.emplace_back(0.500008, 0, 0);
  } else if (tfColorMap == "rgb") {
    colors.emplace_back(0, 0, 1);
    colors.emplace_back(0, 1, 0);
    colors.emplace_back(1, 0, 0);
  } else {
    colors.emplace_back(0.f, 0.f, 0.f);
    colors.emplace_back(1.f, 1.f, 1.f);
  }

  if (tfOpacityMap == "linear") {
    opacities.emplace_back(0.f);
    opacities.emplace_back(1.f);
  } else if (tfOpacityMap == "linearInv") {
    opacities.emplace_back(1.f);
    opacities.emplace_back(0.f);
  } else if (tfOpacityMap == "opaque") {
    opacities.emplace_back(1.f);
  }

  transferFunction.setParam("color", ospray::cpp::CopiedData(colors));
  transferFunction.setParam("opacity", ospray::cpp::CopiedData(opacities));
  transferFunction.setParam("valueRange", valueRange);
  transferFunction.commit();

  return transferFunction;
}

std::vector<float> generateVoxels(vec3i volumeDimensions,
				  int numPoints)
{
  struct Point
  {
    vec3f center;
    float weight;
  };

  // create random number distributions for point center and weight
  std::mt19937 gen(0);

  utility::uniform_real_distribution<float> centerDistribution(-1.f, 1.f);
  utility::uniform_real_distribution<float> weightDistribution(0.1f, 0.3f);

  // populate the points
  std::vector<Point> points(numPoints);

  for (auto &p : points) {
    p.center.x = centerDistribution(gen);
    p.center.y = centerDistribution(gen);
    p.center.z = centerDistribution(gen);

    p.weight = weightDistribution(gen);
  }

  // get world coordinate in [-1.f, 1.f] from logical coordinates in [0,
  // volumeDimension)
  auto logicalToWorldCoordinates = [&](int i, int j, int k) {
				     return vec3f(-1.f + float(i) / float(volumeDimensions.x - 1) * 2.f,
						  -1.f + float(j) / float(volumeDimensions.y - 1) * 2.f,
						  -1.f + float(k) / float(volumeDimensions.z - 1) * 2.f);
				   };

  // generate voxels
  std::vector<float> voxels(volumeDimensions.long_product());

  tasking::parallel_for(volumeDimensions.z,
			[&](int k)
			{
			  for (int j = 0; j < volumeDimensions.y; j++) {
			    for (int i = 0; i < volumeDimensions.x; i++) {
			      // index in array
			      size_t index = size_t(k) * volumeDimensions.z * volumeDimensions.y
				+ size_t(j) * volumeDimensions.x + size_t(i);

			      // compute volume value
			      float value = 0.f;

			      for (auto &p : points) {
				vec3f pointCoordinate = logicalToWorldCoordinates(i, j, k);
				const float distance = length(pointCoordinate - p.center);

				// contribution proportional to weighted inverse-square distance
				// (i.e. gravity)
				value += p.weight / (distance * distance);
			      }

			      voxels[index] = value;
			    }
			  }
			});
  return voxels;

}

std::vector<float> generateVoxels_center_1ch(vec3i volumeDimensions,
					     int numPoints,
					     vec3f p_center){
    
  // get world coordinate in [-1.f, 1.f] from logical coordinates in [0,
  // volumeDimension)
  auto logicalToWorldCoordinates = [&](int i, int j, int k) {
				     return vec3f(-1.f + float(i) / float(volumeDimensions.x - 1) * 2.f,
						  -1.f + float(j) / float(volumeDimensions.y - 1) * 2.f,
						  -1.f + float(k) / float(volumeDimensions.z - 1) * 2.f);
				   };

  // generate voxels
  std::vector<float> voxels(volumeDimensions.long_product());

  tasking::parallel_for(volumeDimensions.z,
			[&](int k)
			{
			  for (int j = 0; j < volumeDimensions.y; j++) {
			    for (int i = 0; i < volumeDimensions.x; i++) {
			      // index in array
			      size_t index = size_t(k) * volumeDimensions.z * volumeDimensions.y
				+ size_t(j) * volumeDimensions.x + size_t(i);

			      // compute volume value
			      float value = 0.f;

			      vec3f pointCoordinate = logicalToWorldCoordinates(i, j, k);
			      const float distance = length(pointCoordinate - p_center);

			      // contribution proportional to weighted inverse-square distance
			      // (i.e. gravity)
			      value += 0.2f / (distance * distance);
			      

			      voxels[index] = value;
			    }
			  }
			});
  return voxels;


}

std::vector<std::vector<float> > generateVoxels_3ch(vec3i volumeDimensions,
				      int numPoints)
{
  std::vector<std::vector<float> > voxels_list;

  voxels_list.push_back(generateVoxels_center_1ch(volumeDimensions, numPoints, vec3f(-.5f, 0, 0)));
  voxels_list.push_back(generateVoxels_center_1ch(volumeDimensions, numPoints, vec3f(0, 0, 0)));
  voxels_list.push_back(generateVoxels_center_1ch(volumeDimensions, numPoints, vec3f(.5f, 0, 0)));  
  return voxels_list;
}

int main(int argc, const char **argv)
{
  // image size
  vec2i imgSize;
  imgSize.x = 1024; // width
  imgSize.y = 768; // height

  // camera
  vec3f cam_pos{0.f, 0.f, 4.f};
  vec3f cam_up{0.f, 1.f, 0.f};
  vec3f cam_view{0.f, 0.f, -1.f};

#ifdef _WIN32
  bool waitForKey = false;
  CONSOLE_SCREEN_BUFFER_INFO csbi;
  if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi)) {
    // detect standalone console: cursor at (0,0)?
    waitForKey = csbi.dwCursorPosition.X == 0 && csbi.dwCursorPosition.Y == 0;
  }
#endif

  // initialize OSPRay; OSPRay parses (and removes) its commandline parameters,
  // e.g. "--osp:debug"
  OSPError init_error = ospInit(&argc, argv);
  if (init_error != OSP_NO_ERROR)
    return init_error;

  // use scoped lifetimes of wrappers to release everything before ospShutdown()
  {
    // create and setup camera
    ospray::cpp::Camera camera("perspective");
    camera.setParam("aspect", imgSize.x / (float)imgSize.y);
    camera.setParam("position", cam_pos);
    camera.setParam("direction", cam_view);
    camera.setParam("up", cam_up);
    camera.commit(); // commit each object to indicate modifications are done

    // create and setup model and mesh
    vec3i volumeDimensions{128};
    int numPoints{10};
    std::vector<std::vector<float> > voxels = generateVoxels_3ch(volumeDimensions, numPoints);
    std::cout << voxels.size()<<" "<<voxels[0].size() << std::endl;
    std::vector<ospray::cpp::SharedData> voxel_data;
    for (const auto &v : voxels) {
      voxel_data.push_back(ospray::cpp::SharedData(v.data(), volumeDimensions));
    }
    
    ospray::cpp::Volume volume("structuredRegular");
    volume.setParam("gridOrigin", vec3f(-1.f));
    volume.setParam("gridSpacing", vec3f(2.f / reduce_max(volumeDimensions)));
    volume.setParam("data", ospray::cpp::SharedData(voxel_data));
    volume.setParam("dimensions", volumeDimensions);
    volume.commit();
    // put the mesh into a model
    ospray::cpp::VolumetricModel model(volume);
    model.setParam("transferFunction", makeTransferFunction(vec2f(0.f, 10.f)));
    model.commit();
    
    // put the model into a group (collection of models)
    ospray::cpp::Group group;
    group.setParam("volume", ospray::cpp::CopiedData(model));
    group.commit();

    // put the group into an instance (give the group a world transform)
    ospray::cpp::Instance instance(group);
    instance.commit();

    // put the instance in the world
    ospray::cpp::World world;
    world.setParam("instance", ospray::cpp::CopiedData(instance));

    // create and setup light for Ambient Occlusion
    ospray::cpp::Light light("ambient");
    light.commit();

    world.setParam("light", ospray::cpp::CopiedData(light));
    world.commit();

    // create renderer, choose Scientific Visualization renderer
    // load multivariant renderer module
    ospLoadModule("multivariant_renderer");
    ospray::cpp::Renderer renderer("multivariant");
    //ospray::cpp::Renderer renderer("scivis");
    std::cout << "using multivariant renderer \n";

    
    // complete setup of renderer
    renderer.setParam("aoSamples", 1);
    renderer.setParam("backgroundColor", 1.0f); // white, transparent
    renderer.commit();

    // create and setup framebuffer
    ospray::cpp::FrameBuffer framebuffer(
        imgSize.x, imgSize.y, OSP_FB_SRGBA, OSP_FB_COLOR | OSP_FB_ACCUM);
    framebuffer.clear();

    // render one frame
    framebuffer.renderFrame(renderer, camera, world);

    // access framebuffer and write its content as PPM file
    uint32_t *fb = (uint32_t *)framebuffer.map(OSP_FB_COLOR);
    rkcommon::utility::writePPM("mtv_firstFrameCpp.ppm", imgSize.x, imgSize.y, fb);
    framebuffer.unmap(fb);
    std::cout << "rendering initial frame to firstFrameCpp.ppm" << std::endl;

    // render 10 more frames, which are accumulated to result in a better
    // converged image
    for (int frames = 0; frames < 10; frames++)
      framebuffer.renderFrame(renderer, camera, world);

    fb = (uint32_t *)framebuffer.map(OSP_FB_COLOR);
    rkcommon::utility::writePPM(
        "mtv_accumulatedFrameCpp.ppm", imgSize.x, imgSize.y, fb);
    framebuffer.unmap(fb);
    std::cout << "rendering 10 accumulated frames to accumulatedFrameCpp.ppm"
              << std::endl;

    ospray::cpp::PickResult res =
        framebuffer.pick(renderer, camera, world, 0.5f, 0.5f);

    if (res.hasHit) {
      std::cout << "picked geometry [instance: " << res.instance.handle()
                << ", model: " << res.model.handle()
                << ", primitive: " << res.primID << "]" << std::endl;
    }
  }

  ospShutdown();

#ifdef _WIN32
  if (waitForKey) {
    printf("\n\tpress any key to exit");
    _getch();
  }
#endif

  return 0;
}
